## class的两个分类
1. class with pointer members
```cpp
class B {
    int* data;
public:
    B(int val) {
        data = new int(val);
    }
    ~B() {
        delete data;
    }
    // 拷贝构造函数
    B(const B& other) {
        data = new int(*other.data);  // 深拷贝
    }
    // 赋值操作符
    B& operator=(const B& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }
};
```
2. class without pointer members
```cpp
class A {
    int x;
    double y;
};
//不需要写析构函数、拷贝构造函数或赋值操作符。
//编译器生成的默认版本就能很好地工作。
//拷贝时成员变量直接复制即可，安全可靠。 
```
## 防御式声明guard
大多在头文件中使用，以避免重复引入时可能发生的错误。
```cpp
complex.h
# ifndef _COMPLEX_
# define _COMPLEX_
...
# endif
```
## class template（模版）
```cpp
template<typename T> //告诉编译器变量类型我还没决定
class complex
{
private:
	# 用模版可以使变量类型不写死，T只是一个符号
	T re, im; // re，im分别对应复数的实部和虚部
}
```
```cpp
# 用法
{
	complex<double> c1(2.5,1.5);
	complex<int> c2(2,6);
}
```
## class的声明 declaration
```cpp
class complex
{
public:
	complex (double r = 0, double i = 0)
		: re(r), im(i)
	{}
	complex& operator += (const complex&);
	double real () const { return re; }
	double imag () const { return im; }
private:
	double re, im;

	friend complex& __doapl(complex*, const complex&);
}
```
## inline内联函数
函数在class body内定义完成，便自动成为inline候选人。
是否成为inline函数由编译器视其简易程度决定，简单则能成。
```cpp
class complex
{
public:
	complex (double r = 0, double i = 0)
		: re(r), im(i)
	{}
	complex& operator += (const complex&);
	double real () const { return re; }
	double imag () const { return im; }
private:
	double re, im;

	friend complex& __doapl(complex*, const complex&);
}
```
```cpp
#如果函数不在本体内定义却想成为inline候选人，可以用inline关键字，但最终能否还是取决于编译器
inline double
imag(const complex& x)
{
	return x.imag ();
}
```
## access level访问级别
```cpp
class complex
{
public: //公开。内容主要是允许外部访问的函数
	complex (double r = 0, double i = 0)
		: re(r), im(i)
	{}
	complex& operator += (const complex&);
	double real () const { return re; }
	double imag () const { return im; }
private: //私有，只有class内能访问。内容主要是数据和函数
	double re, im;

	friend complex& __doapl(complex*, const complex&);
}
```
## constructor 构造函数ctor
```cpp
class complex
{
public:
	# 构造函数名称跟class一致且没有返回类型，r/i为默认值
	complex (double r = 0, double i = 0)
		: re(r), im(i) //initialization list 初始列
	{}
	# 也可以写成这种形式，但不推荐
	// complex (double r = 0, double i = 0) {re = r; im = i}
	complex& operator += (const complex&);
	double real () const { return re; }
	double imag () const { return im; }
private:
	double re, im;

	friend complex& __doapl(complex*, const complex&);
}
```
```cpp
# 创建对象的例子
complex c1(2,1);
complex c2;
complex* p = new complex(4);
```
## overloading 重载 即多个ctor
```cpp
class complex
{
public:
	complex (double r = 0, double i = 0)
		: re(r), im(i)
	{}
	complex& operator += (const complex&);
	double real () const { return re; }
	// void real(double r) { re = r } 对上面real函数的重载，同名但是功能不同
	// real函数编译后的实际名称可能是:(取决于编译器)
	// ?real@ComplexTutuzhuoQBENXZ , ?real@ComplexTutuzhuoQAENABN@Z
	double imag () const { return im; }
private:
	double re, im;

	friend complex& __doapl(complex*, const complex&);
}
```
## 相同class的各个objects互为友元friends
```cpp
class complex
{
public:
	complex (double r = 0, double i = 0)
		: re(r), im(i)
	{}
	# friends可以直接调用参数而不需要通过函数调用
	int func(const complex& param)
	{ return param.re + param.im; }

private:
	double re, im;
}
```
```cpp
{
	complex c1(2,1);
	complex c2;

	c2.func(c1);
}
```
## class boby外的各种定义definitions
什么情况下可以pass by reference
什么情况下可以return by reference
```cpp
inline complex&
__doapl(complex* ths, const complex& r)
{
	ths->re += r.re; //第一个参数ths将会被改动
	ths->im += r.im; //第二个参数r不会被改动
	return *ths;
}

inline complex&
complex::operator += (const complex& r)
{
	return __doapl (this, r);
}
```
## 操作符重载operator overloading
### 1-成员函数
```cpp
inline complex&
__doapl(complex* ths, const complex& r)
{
	ths->re += r.re; 
	ths->im += r.im; 
	return *ths; // 传递者无需知道接收者是以reference形式接收
}

inline complex&
// 形式如class name::function name的为成员函数
complex::operator += (const complex& r) 
{
	return __doapl (this, r);
}
```
```cpp
# 解释
inline complex&
// 任何一个成员函数都有一个隐藏的this
complex::operator += (/*this*/, const complex& r) 
{
	return __doapl (this, r); // 多包了一层函数，直接加也可以
}
```
```cpp
# 用法
{
	complex c1(2,1);
	complex c2(5);

	c2 += c1;
}
```
### 2-非成员函数 无this
```cpp
# globle function
# 因为有三种可能的不同用法，所以写了三个函数
# 返回的是local object，所以绝不是return by reference，而是return by value
inline complex
operator + (const complex& x, const complex& y)
{
	return complex (real (x) + real (y), imag (x) + imag (y));
}

inline complex
operator + (const complex& x, double y)
{
	return complex (real (x) + y, imag (x));
}

inline complex
operator + (double x, const complex& y)
{
	return complex (x + real(y), imag (y));
}
```
```cpp
# 三种可能的用法
{
complex c1(2,1);
complex c2;

c2 = c1 + c2;
c2 = c1 + 5;
c2 = 7 + c1;
}
```
tips：创建临时对象:`typename ();` == `int ()`
```cpp
{
complex c1(2,1);
complex c2;
complex();
complex(4,5);
// 作为临时对象complex()和complex(4,5)的生命到这里就已经结束了 

cout << complex(2);
}
```
```cpp
# 共轭复数
inline complex
conj (const complex& x)
{
	return complex (real (x), -imag (x));
}
```
```cpp
# 针对复数重写 <<
#include<iostream.h>
ostream&
operator << (ostream& os, const complex& x)
{
	return os << '(' << real (x) << ',' << imag (x) << ')';
}

# 用法
complex c1(2,1);
cout << conj(c1);
cout << c1 << conj(c1); // 本来<<的返回类型写成void就行，为了满足这种连续多个<<的用法，就把返回类型设置成ostream
```